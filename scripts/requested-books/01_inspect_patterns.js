/**
 * Requested Books — Phase 0
 * Script 01: Pattern Inspection
 *
 * Consumes the raw export JSON generated by:
 *   scripts/requested-books/00_export_channel_raw.js
 *
 * Produces inspection-friendly CSV outputs under:
 *   scripts/requested-books/output/analysis/
 *
 * This script is intentionally conservative:
 * - No state inference
 * - No Slack API calls
 * - No DB writes
 * - No filtering of “irrelevant” threads
 */

import fs from "fs";
import path from "path";

const DEFAULT_INPUT = path.resolve(
  "scripts/requested-books/output/raw/requested_books_raw.json"
);
const OUTPUT_DIR = path.resolve(
  "scripts/requested-books/output/analysis"
);

const KEYWORDS = [
  "notified",
  "arrived",
  "ordered",
  "picked up",
  "cancelled",
  "ready",
];

/**
 * CSV helpers
 */
function csvEscape(value) {
  if (value === null || value === undefined) return "";
  const s = String(value);
  // Escape quotes by doubling them
  const escaped = s.replace(/"/g, '""');
  // Wrap if contains comma, quote, or newline
  if (/[",\n\r]/.test(escaped)) return `"${escaped}"`;
  return escaped;
}

function writeCsv(filePath, headers, rows) {
  const lines = [];
  lines.push(headers.map(csvEscape).join(","));
  for (const row of rows) {
    lines.push(headers.map((h) => csvEscape(row[h])).join(","));
  }
  fs.writeFileSync(filePath, lines.join("\n") + "\n", "utf-8");
}

function toBool(v) {
  return v ? "true" : "false";
}

function safeLen(text) {
  if (text === null || text === undefined) return 0;
  return String(text).length;
}

function parseJsonFile(filePath) {
  const raw = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(raw);
}

function ensureDir(dirPath) {
  fs.mkdirSync(dirPath, { recursive: true });
}

function isoToDate(iso) {
  // Date parsing via JS Date
  const d = new Date(iso);
  if (Number.isNaN(d.getTime())) return null;
  return d;
}

function tsToDate(tsStr) {
  // Slack ts is a string like "1767133357.453599"
  // Date expects milliseconds
  const n = Number(tsStr);
  if (!Number.isFinite(n)) return null;
  return new Date(n * 1000);
}

function daysBetween(a, b) {
  // a, b are Date
  const ms = b.getTime() - a.getTime();
  return ms / (1000 * 60 * 60 * 24);
}

/**
 * Analysis helpers
 */
function hasReactions(messageObj) {
  const r = messageObj?.reactions;
  return Array.isArray(r) && r.length > 0;
}

function collectAllText(thread) {
  const parts = [];
  if (thread?.parent?.text) parts.push(thread.parent.text);
  for (const r of thread?.replies || []) {
    if (r?.text) parts.push(r.text);
  }
  return parts.join("\n");
}

function containsAnyKeyword(text) {
  if (!text) return false;
  const lower = String(text).toLowerCase();
  return KEYWORDS.some((k) => lower.includes(k));
}

function matchNumericDates(text) {
  if (!text) return false;
  const s = String(text);

  // Common patterns:
  // - 12/19, 12/19/2025, 1/3, 01/03/26
  // - 2025-12-19
  // - 12-19-2025 (less common, but included)
  const re =
    /\b\d{1,2}\/\d{1,2}(?:\/\d{2,4})?\b|\b\d{4}-\d{2}-\d{2}\b|\b\d{1,2}-\d{1,2}-\d{2,4}\b/;
  return re.test(s);
}

/**
 * Main execution
 */
function run() {
  const inputPath = process.argv[2]
    ? path.resolve(process.argv[2])
    : DEFAULT_INPUT;

  if (!fs.existsSync(inputPath)) {
    console.error(`Input file not found: ${inputPath}`);
    process.exit(1);
  }

  const data = parseJsonFile(inputPath);

  if (!data || !Array.isArray(data.threads)) {
    console.error(
      "Malformed input JSON: expected top-level { threads: [...] }"
    );
    process.exit(1);
  }

  ensureDir(OUTPUT_DIR);

  const exportedAt = isoToDate(data.exported_at) || new Date();

  /**
   * 1) threads_summary.csv
   */
  const threadsSummaryHeaders = [
    "thread_ts",
    "parent_ts",
    "parent_user",
    "parent_text_length",
    "reply_count",
    "has_replies",
    "parent_has_reactions",
    "reply_has_reactions",
    "first_reply_ts",
    "last_reply_ts",
    "thread_age_days",
  ];

  const threadsSummaryRows = data.threads
    .map((t) => {
      const parentTs = t?.parent?.ts || t?.thread_ts || "";
      const replyCount = Array.isArray(t.replies) ? t.replies.length : 0;

      const replyDates = (t.replies || [])
        .map((r) => tsToDate(r.ts))
        .filter(Boolean)
        .sort((a, b) => a.getTime() - b.getTime());

      const firstReplyTs =
        replyDates.length > 0 ? t.replies[0]?.ts || "" : "";
      const lastReplyTs =
        replyDates.length > 0
          ? t.replies[t.replies.length - 1]?.ts || ""
          : "";

      const parentDate = tsToDate(parentTs);
      const ageDays =
        parentDate && exportedAt
          ? daysBetween(parentDate, exportedAt)
          : "";

      const replyHasReactions =
        (t.replies || []).some((r) => hasReactions(r)) || false;

      return {
        thread_ts: t.thread_ts || "",
        parent_ts: parentTs,
        parent_user: t?.parent?.user || "",
        parent_text_length: safeLen(t?.parent?.text),
        reply_count: replyCount,
        has_replies: toBool(replyCount > 0),
        parent_has_reactions: toBool(hasReactions(t.parent)),
        reply_has_reactions: toBool(replyHasReactions),
        first_reply_ts: firstReplyTs,
        last_reply_ts: lastReplyTs,
        thread_age_days:
          typeof ageDays === "number"
            ? ageDays.toFixed(2)
            : ageDays,
      };
    })
    .sort((a, b) => String(a.thread_ts).localeCompare(String(b.thread_ts)));

  writeCsv(
    path.join(OUTPUT_DIR, "threads_summary.csv"),
    threadsSummaryHeaders,
    threadsSummaryRows
  );

  /**
   * 2) emoji_usage.csv (one row per emoji occurrence)
   */
  const emojiUsageHeaders = [
    "emoji_name",
    "location",
    "thread_ts",
    "message_ts",
    "message_user",
  ];

  const emojiUsageRows = [];

  for (const t of data.threads) {
    const threadTs = t.thread_ts || "";

    // Parent reactions
    const parentReactions = t?.parent?.reactions || [];
    for (const rxn of parentReactions) {
      const name = rxn?.name;
      if (!name) continue;
      emojiUsageRows.push({
        emoji_name: name,
        location: "parent",
        thread_ts: threadTs,
        message_ts: t?.parent?.ts || "",
        message_user: t?.parent?.user || "",
      });
    }

    // Reply reactions
    for (const r of t?.replies || []) {
      const replyReactions = r?.reactions || [];
      for (const rxn of replyReactions) {
        const name = rxn?.name;
        if (!name) continue;
        emojiUsageRows.push({
          emoji_name: name,
          location: "reply",
          thread_ts: threadTs,
          message_ts: r?.ts || "",
          message_user: r?.user || "",
        });
      }
    }
  }

  emojiUsageRows.sort((a, b) => {
    const en = String(a.emoji_name).localeCompare(String(b.emoji_name));
    if (en !== 0) return en;
    const loc = String(a.location).localeCompare(String(b.location));
    if (loc !== 0) return loc;
    return String(a.thread_ts).localeCompare(String(b.thread_ts));
  });

  writeCsv(
    path.join(OUTPUT_DIR, "emoji_usage.csv"),
    emojiUsageHeaders,
    emojiUsageRows
  );

  /**
   * 3) reply_patterns.csv (one row per thread)
   */
  const replyPatternsHeaders = [
    "thread_ts",
    "reply_count",
    "unique_reply_users",
    "single_responder",
    "multiple_responders",
    "contains_numeric_dates",
    "contains_keywords",
  ];

  const replyPatternsRows = data.threads
    .map((t) => {
      const replies = Array.isArray(t.replies) ? t.replies : [];
      const replyCount = replies.length;
      const users = new Set(
        replies.map((r) => r?.user).filter(Boolean)
      );

      const allText = collectAllText(t);

      return {
        thread_ts: t.thread_ts || "",
        reply_count: replyCount,
        unique_reply_users: users.size,
        single_responder: toBool(users.size === 1 && replyCount > 0),
        multiple_responders: toBool(users.size > 1),
        contains_numeric_dates: toBool(matchNumericDates(allText)),
        contains_keywords: toBool(containsAnyKeyword(allText)),
      };
    })
    .sort((a, b) => String(a.thread_ts).localeCompare(String(b.thread_ts)));

  writeCsv(
    path.join(OUTPUT_DIR, "reply_patterns.csv"),
    replyPatternsHeaders,
    replyPatternsRows
  );

  /**
   * 4) keyword_frequency.csv (fixed keyword set)
   */
  const keywordFrequencyHeaders = [
    "keyword",
    "occurrence_count",
    "threads_with_keyword",
  ];

  const keywordStats = new Map(
    KEYWORDS.map((k) => [k, { occurrence_count: 0, threads: new Set() }])
  );

  for (const t of data.threads) {
    const threadTs = t.thread_ts || "";
    const textParts = [];

    if (t?.parent?.text) textParts.push(String(t.parent.text));
    for (const r of t?.replies || []) {
      if (r?.text) textParts.push(String(r.text));
    }

    for (const part of textParts) {
      const lower = part.toLowerCase();
      for (const kw of KEYWORDS) {
        if (lower.includes(kw)) {
          const stat = keywordStats.get(kw);
          stat.occurrence_count += 1;
          stat.threads.add(threadTs);
        }
      }
    }
  }

  const keywordFrequencyRows = KEYWORDS.map((kw) => {
    const stat = keywordStats.get(kw);
    return {
      keyword: kw,
      occurrence_count: stat.occurrence_count,
      threads_with_keyword: stat.threads.size,
    };
  });

  writeCsv(
    path.join(OUTPUT_DIR, "keyword_frequency.csv"),
    keywordFrequencyHeaders,
    keywordFrequencyRows
  );

  console.log("Pattern inspection complete. Wrote CSVs to:");
  console.log(OUTPUT_DIR);
  console.log("- threads_summary.csv");
  console.log("- emoji_usage.csv");
  console.log("- reply_patterns.csv");
  console.log("- keyword_frequency.csv");
}

run();
